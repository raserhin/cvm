# generated by datamodel-codegen:
#   filename:  skip_money_swagger.yml

from __future__ import annotations

from enum import Enum
from typing import Any, List, Optional, Union

from pydantic import BaseModel, Field


class AcknowledgementErrorDetails(BaseModel):
    code: Optional[float] = Field(None, description='Error code')
    message: Optional[str] = Field(None, description='Error message')


class Affiliate(BaseModel):
    """
    An affiliate that receives fees from a swap
    """

    address: Optional[str] = Field(None, description='Address to which to pay the fee')
    basis_points_fee: Optional[str] = Field(
        None, description='Bps fee to pay to the affiliate'
    )


class ApiError(BaseModel):
    message: Optional[str] = Field(None, description='Error message')


class Asset(BaseModel):
    chain_id: Optional[str] = Field(None, description='Chain-id of the asset')
    coingecko_id: Optional[str] = Field(None, description='Coingecko id of the asset')
    decimals: Optional[float] = Field(
        None, description='Number of decimals used for amounts of the asset'
    )
    denom: Optional[str] = Field(None, description='Denom of the asset')
    description: Optional[str] = Field(None, description='Description of the asset')
    is_cw20: Optional[bool] = Field(
        None, description='Indicates whether asset is a CW20 token'
    )
    is_evm: Optional[bool] = Field(
        None, description='Indicates whether asset is an EVM token'
    )
    logo_uri: Optional[str] = Field(
        None, description='URI pointing to an image of the logo of the asset'
    )
    name: Optional[str] = Field(None, description='Name of the asset')
    origin_chain_id: Optional[str] = Field(
        None,
        description='Chain-id of the origin of the asset. If this is an ibc denom, this is the chain-id of the asset that the ibc token represents',
    )
    origin_denom: Optional[str] = Field(
        None,
        description='Denom of the origin of the asset. If this is an ibc denom, this is the original denom that the ibc token represents',
    )
    recommended_symbol: Optional[str] = Field(
        None,
        description='Recommended symbol of the asset used to differentiate between bridged assets with the same symbol, e.g. USDC.axl for Axelar USDC and USDC.grv for Gravity USDC',
    )
    symbol: Optional[str] = Field(
        None, description='Symbol of the asset, e.g. ATOM for uatom'
    )
    token_contract: Optional[str] = Field(
        None,
        description='Address of the contract for the asset, e.g. if it is a CW20 or ERC20 token',
    )
    trace: Optional[str] = Field(
        None,
        description='The forward slash delimited sequence of ibc ports and channels that can be traversed to unwind an ibc token to its origin asset.',
    )


class AutopilotAction(Enum):
    LIQUID_STAKE = 'LIQUID_STAKE'
    CLAIM = 'CLAIM'


class AutopilotMsg(BaseModel):
    action: Optional[AutopilotAction] = None
    receiver: Optional[str] = None


class AutopilotMsgWrapper(BaseModel):
    autpilot_msg: Optional[AutopilotMsg] = None


class AxelarTransfer(BaseModel):
    """
    A transfer facilitated by the Axelar bridge
    """

    asset: Optional[str] = Field(None, description='Axelar-name of the asset to bridge')
    fee_amount: Optional[str] = Field(
        None,
        description='Amount of the fee asset to be paid as the Axelar bridge fee. This is denominated in the fee asset.',
    )
    fee_asset: Optional[Asset] = None
    from_chain: Optional[str] = Field(
        None,
        description='Name for source chain of the bridge transaction used on Axelar',
    )
    from_chain_id: Optional[str] = Field(
        None,
        description='Canonical chain-id of the source chain of the bridge transaction',
    )
    is_testnet: Optional[bool] = Field(
        None, description='Whether the source and destination chains are both testnets'
    )
    should_unwrap: Optional[bool] = Field(
        None,
        description='Whether to unwrap the asset at the destination chain (from ERC-20 to native)',
    )
    to_chain: Optional[str] = Field(
        None,
        description='Name for destination chain of the bridge transaction used on Axelar',
    )
    to_chain_id: Optional[str] = Field(
        None,
        description='Canonical chain-id of the destination chain of the bridge transaction',
    )
    usd_fee_amount: Optional[str] = Field(
        None,
        description='Amount of the fee asset to be paid as the Axelar bridge fee, converted to USD value',
    )


class AxelarTransferState(Enum):
    """
    Axelar transfer state: <br/> * AXELAR_TRANSFER_UNKNOWN - Unknown error <br/> * AXELAR_TRANSFER_PENDING_CONFIRMATION - Axelar transfer is pending confirmation <br/> * AXELAR_TRANSFER_PENDING_RECEIPT - Axelar transfer is pending receipt at destination <br/> * AXELAR_TRANSFER_SUCCESS - Axelar transfer succeeded and assets have been received <br/> * AXELAR_TRANSFER_FAILURE - Axelar transfer failed <br/>

    """

    AXELAR_TRANSFER_UNKNOWN = 'AXELAR_TRANSFER_UNKNOWN'
    AXELAR_TRANSFER_PENDING_CONFIRMATION = 'AXELAR_TRANSFER_PENDING_CONFIRMATION'
    AXELAR_TRANSFER_PENDING_RECEIPT = 'AXELAR_TRANSFER_PENDING_RECEIPT'
    AXELAR_TRANSFER_SUCCESS = 'AXELAR_TRANSFER_SUCCESS'
    AXELAR_TRANSFER_FAILURE = 'AXELAR_TRANSFER_FAILURE'


class AxelarTransferType(Enum):
    """
    Axelar transfer type: <br/> * AXELAR_TRANSFER_CONTRACT_CALL_WITH_TOKEN - GMP contract call with token transfer type <br/> * AXELAR_TRANSFER_SEND_TOKEN - Send token transfer type <br/>

    """

    AXELAR_TRANSFER_CONTRACT_CALL_WITH_TOKEN = (
        'AXELAR_TRANSFER_CONTRACT_CALL_WITH_TOKEN'
    )
    AXELAR_TRANSFER_SEND_TOKEN = 'AXELAR_TRANSFER_SEND_TOKEN'


class AxelarTransferWrapper(BaseModel):
    axelar_transfer: Optional[AxelarTransfer] = None


class BankSend(BaseModel):
    pass


class BankSendWrapper(BaseModel):
    bank_send: Optional[BankSend] = None


class BridgeType(Enum):
    IBC = 'IBC'
    AXELAR = 'AXELAR'


class ContractCallWithTokenErrorType(Enum):
    """
    ContractCallWithToken errors: <br/> * CONTRACT_CALL_WITH_TOKEN_EXECUTION_ERROR - Error occurred during the execute transaction <br/>

    """

    CONTRACT_CALL_WITH_TOKEN_EXECUTION_ERROR = (
        'CONTRACT_CALL_WITH_TOKEN_EXECUTION_ERROR'
    )


class CosmWasmContractMsg(BaseModel):
    contract_address: Optional[str] = Field(
        None, description='Address of the contract to execute the message on'
    )
    msg: Optional[str] = Field(None, description='JSON string of the message')


class CosmWasmContractMsgWrapper(BaseModel):
    wasm_msg: Optional[CosmWasmContractMsg] = None


class Erc20Approval(BaseModel):
    """
    An ERC20 token contract approval
    """

    amount: Optional[str] = Field(None, description='Amount of the approval')
    spender: Optional[str] = Field(None, description='Address of the spender')
    token_contract: Optional[str] = Field(
        None, description='Address of the ERC20 token contract'
    )


class EvmTx(BaseModel):
    """
    A transaction on an EVM chain
    """

    chain_id: Optional[str] = Field(
        None, description='Chain-id of the chain that the transaction is intended for'
    )
    data: Optional[str] = Field(None, description='Data of the transaction')
    required_erc20_approvals: Optional[List[Erc20Approval]] = Field(
        None, description='ERC20 approvals required for the transaction'
    )
    to: Optional[str] = Field(
        None, description='Address of the recipient of the transaction'
    )
    value: Optional[str] = Field(None, description='Amount of the transaction')


class EvmTxWrapper(BaseModel):
    evm_tx: Optional[EvmTx] = None


class GasPriceInfo(BaseModel):
    """
    Gas price tiers
    """

    average: Optional[str] = Field(None, description='Average gas price')
    high: Optional[str] = Field(None, description='High gas price')
    low: Optional[str] = Field(None, description='Low gas price')


class FeeAsset(BaseModel):
    """
    Asset used to pay gas fees and the recommended price tiers. Assets and gas price recommendations are sourced from the [keplr chain registry](https://github.com/chainapsis/keplr-chain-registry)
    """

    denom: Optional[str] = Field(None, description='Asset denom')
    gas_price_info: Optional[GasPriceInfo] = Field(None, description='Gas price tiers')


class GRPCStatusCode(BaseModel):
    __root__: float = Field(
        ...,
        description='grpc status codes as defined [here](https://grpc.github.io/grpc/core/md_doc_statuscodes.html)',
    )


class MultiChainMsg(BaseModel):
    """
    A message that interacts with multiple chains
    """

    chain_id: Optional[str] = Field(
        None,
        description='Chain-id of the chain that the transaction containing the message is intended for',
    )
    msg: Optional[str] = Field(None, description='JSON string of the message')
    msg_type_url: Optional[str] = Field(None, description='TypeUrl of the message')
    path: Optional[List[str]] = Field(
        None,
        description='Path of chain-ids that the message is intended to interact with',
    )


class MultiChainMsgWrapper(BaseModel):
    multi_chain_msg: Optional[MultiChainMsg] = None


class OptionalAsset(BaseModel):
    asset: Optional[Asset] = None
    asset_found: Optional[bool] = Field(None, description='Whether the asset was found')


class PacketErrorType(Enum):
    """
    Packet error type: <br/> * PACKET_ERROR_UNKNOWN - Unknown error <br/> * PACKET_ERROR_ACKNOWLEDGEMENT - Packet acknowledgement error <br/> * PACKET_ERROR_TIMEOUT - Packet timed out <br/>

    """

    PACKET_ERROR_UNKNOWN = 'PACKET_ERROR_UNKNOWN'
    PACKET_ERROR_ACKNOWLEDGEMENT = 'PACKET_ERROR_ACKNOWLEDGEMENT'
    PACKET_ERROR_TIMEOUT = 'PACKET_ERROR_TIMEOUT'


class PacketTransaction(BaseModel):
    chain_id: Optional[str] = Field(
        None, description='Chain ID the packet event occurs on'
    )
    explorer_link: Optional[str] = Field(
        None, description='Link to the transaction on block explorer'
    )
    tx_hash: Optional[str] = Field(
        None, description='Hash of the transaction the packet event occurred in'
    )


class PostHandler(BaseModel):
    __root__: Union[CosmWasmContractMsgWrapper, AutopilotMsgWrapper]


class Reason(Enum):
    """
    Recommendation reason: <br/> * UNKNOWN - Unknown recommendation reason. <br/> * MOST_LIQUID - Highest liquidity form of the transferred token on the destination chain. <br/> * BASE_TOKEN - The base token if the destination chain is the origin chain of the source token. <br/> * DIRECT - The token resulting from the least amount of transfers to the destination chain.

    """

    UNKNOWN = 'UNKNOWN'
    MOST_LIQUID = 'MOST_LIQUID'
    BASE_TOKEN = 'BASE_TOKEN'
    DIRECT = 'DIRECT'


class SendTokenErrorType(Enum):
    """
    SendToken error types: <br/> * SEND_TOKEN_EXECUTION_ERROR - Error occurred during the execute transaction <br/>

    """

    SEND_TOKEN_EXECUTION_ERROR = 'SEND_TOKEN_EXECUTION_ERROR'


class StatusErrorType(Enum):
    """
    Packet error type: <br/> * STATUS_ERROR_UNKNOWN - Unknown error <br/> * STATUS_ERROR_TRANSACTION_EXECUTION - Error was encountered during transaction execution <br/> * STATUS_ERROR_INDEXING - Error was encountered while indexing the transaction and packet data <br/> * STATUS_ERROR_TRANSFER - The transfer failed to complete successfully <br/>

    """

    STATUS_ERROR_UNKNOWN = 'STATUS_ERROR_UNKNOWN'
    STATUS_ERROR_TRANSACTION_EXECUTION = 'STATUS_ERROR_TRANSACTION_EXECUTION'
    STATUS_ERROR_INDEXING = 'STATUS_ERROR_INDEXING'
    STATUS_ERROR_TRANSFER = 'STATUS_ERROR_TRANSFER'


class SwapOperation(BaseModel):
    """
    Description of a single swap operation
    """

    denom_in: Optional[str] = Field(None, description='Input denom of the swap')
    denom_out: Optional[str] = Field(None, description='Output denom of the swap')
    pool: Optional[str] = Field(
        None, description='Identifier of the pool to use for the swap'
    )


class SwapVenue(BaseModel):
    """
    A venue on which swaps can be exceuted
    """

    chain_id: Optional[str] = Field(None, description='Chain-id of the swap venue')
    name: Optional[str] = Field(None, description='Name of the swap venue')


class TransactionExecutionErrorDetails(BaseModel):
    code: Optional[float] = Field(None, description='Error code')
    message: Optional[str] = Field(None, description='Error message')


class TransactionState(Enum):
    """
    Transaction state: <br/> * STATE_SUBMITTED - The initial transaction has been submitted to Skip API but not observed on chain yet. <br/> * STATE_PENDING - The initial transaction has been observed on chain, and there are still pending actions. <br/> * STATE_RECEIVED - The transfer asset has been released, but there are still packet events that are not indexed. <br/> * STATE_COMPLETED_SUCCESS - The initial transaction and any subsequent transfers have completed successfully and lifecycle tracking has concluded. <br/> * STATE_COMPLETED_ERROR - The initial transaction or a subsequent transfer failed and lifecycle tracking has concluded. <br/> * STATE_ABANDONED - Tracking for the transaction has been abandoned. This happens if the cross-chain  sequence of actions stalls for more than 10 minutes or if the initial transaction does not get observed in a block for 5 minutes.

    """

    STATE_SUBMITTED = 'STATE_SUBMITTED'
    STATE_PENDING = 'STATE_PENDING'
    STATE_RECEIVED = 'STATE_RECEIVED'
    STATE_COMPLETED_SUCCESS = 'STATE_COMPLETED_SUCCESS'
    STATE_COMPLETED_ERROR = 'STATE_COMPLETED_ERROR'
    STATE_ABANDONED = 'STATE_ABANDONED'


class Transfer(BaseModel):
    """
    A cross-chain transfer
    """

    chain_id: Optional[str] = Field(
        None, description='Chain-id on which the transfer is initiated'
    )
    channel: Optional[str] = Field(
        None, description='Channel to use to initiate the transfer'
    )
    dest_denom: Optional[str] = Field(
        None, description='Denom of the destionation asset of the transfer'
    )
    pfm_enabled: Optional[bool] = Field(
        None,
        description='Whether pfm is enabled on the chain where the transfer is initiated',
    )
    port: Optional[str] = Field(
        None, description='Port to use to initiate the transfer'
    )


class TransferState(Enum):
    """
    Transfer state: <br/> * TRANSFER_UNKNOWN - Transfer state is not known. <br/> * TRANSFER_PENDING - The send packet for the transfer has been committed and the transfer is pending. <br/> * TRANSFER_RECEIVED - The transfer packet has been received by the destination chain. It can still fail and revert if it is part  of a multi-hop PFM transfer. <br/> * TRANSFER_SUCCESS - The transfer has been successfully completed and will not revert. <br/> * TRANSFER_FAILURE - The transfer has failed.

    """

    TRANSFER_UNKNOWN = 'TRANSFER_UNKNOWN'
    TRANSFER_PENDING = 'TRANSFER_PENDING'
    TRANSFER_RECEIVED = 'TRANSFER_RECEIVED'
    TRANSFER_SUCCESS = 'TRANSFER_SUCCESS'
    TRANSFER_FAILURE = 'TRANSFER_FAILURE'


class NextBlockingTransfer(BaseModel):
    """
    Indicates which entry in the `transfer_sequence` field that the transfer is blocked on. Will be null if there is no blocked transfer.
    """

    transfer_sequence_index: Optional[int] = Field(
        None,
        description='The index of the entry in the `transfer_sequence` field that the transfer is blocked on.',
    )


class TransferAssetRelease(BaseModel):
    """
    Indicates location and denom of transfer asset release.
    """

    chain_id: Optional[str] = Field(
        None,
        description='The chain ID of the chain that the transfer asset is released on.',
    )
    denom: Optional[str] = Field(
        None, description='The denom of the asset that is released.'
    )


class TransferWrapper(BaseModel):
    transfer: Optional[Transfer] = None


class AssetBetweenChains(BaseModel):
    asset_on_source: Optional[Asset] = None
    asset_on_dest: Optional[Asset] = None
    txs_required: Optional[int] = Field(
        None, description='Number of transactions required to transfer the asset'
    )
    bridges: Optional[List[BridgeType]] = Field(
        None, description='Bridges that are used to transfer the asset'
    )


class AssetRecommendation(BaseModel):
    asset: Optional[Asset] = Field(None, description='Asset that is recommended')
    reason: Optional[Reason] = Field(
        None, description='Reason for recommending the asset'
    )


class Chain(BaseModel):
    bech32_prefix: Optional[str] = Field(None, description='Bech32 prefix of the chain')
    chain_id: Optional[str] = Field(None, description='Chain-id of the chain')
    chain_name: Optional[str] = Field(None, description='Name of the chain')
    fee_assets: Optional[List[FeeAsset]] = Field(
        None, description='Fee assets of the chain'
    )
    logo_uri: Optional[str] = Field(None, description='chain logo URI')
    pfm_enabled: Optional[bool] = Field(
        None, description='Whether the PFM module is enabled on the chain'
    )
    chain_type: Optional[str] = Field(
        None, description='Type of chain, e.g. "cosmos" or "evm"'
    )


class ContractCallWithTokenError(BaseModel):
    message: Optional[str] = Field(None, description='Error message')
    type: Optional[ContractCallWithTokenErrorType] = None


class ContractCallWithTokenTxs(BaseModel):
    approve_tx: Optional[PacketTransaction] = None
    confirm_tx: Optional[PacketTransaction] = None
    error: Optional[ContractCallWithTokenError] = None
    execute_tx: Optional[PacketTransaction] = None
    gas_paid_tx: Optional[PacketTransaction] = None
    send_tx: Optional[PacketTransaction] = None


class Error(BaseModel):
    code: Optional[GRPCStatusCode] = Field(None, description='Error code')
    details: Optional[List[str]] = Field(None, description='Additional error details')
    message: Optional[str] = Field(None, description='Error message')


class Msg(BaseModel):
    __root__: Union[MultiChainMsgWrapper, EvmTxWrapper]


class PacketError(BaseModel):
    details: Optional[Union[Any, AcknowledgementErrorDetails]] = None
    message: Optional[str] = Field(None, description='Error message')
    type: Optional[PacketErrorType] = None


class SendTokenError(BaseModel):
    message: Optional[str] = Field(None, description='Error message')
    type: Optional[SendTokenErrorType] = None


class SendTokenTxs(BaseModel):
    confirm_tx: Optional[PacketTransaction] = None
    error: Optional[SendTokenError] = None
    execute_tx: Optional[PacketTransaction] = None
    send_tx: Optional[PacketTransaction] = None


class StatusError(BaseModel):
    details: Optional[TransactionExecutionErrorDetails] = None
    message: Optional[str] = Field(None, description='Error message')
    type: Optional[StatusErrorType] = None


class SwapExactCoinIn(BaseModel):
    """
    Specification of a swap with an exact amount in
    """

    swap_amount_in: Optional[str] = Field(None, description='Amount to swap in')
    swap_operations: Optional[List[SwapOperation]] = Field(
        None, description='Operations required to execute the swap'
    )
    swap_venue: Optional[SwapVenue] = Field(
        None, description='Swap venue that this swap should execute on'
    )
    price_impact_percent: Optional[str] = Field(
        None, description='Price impact of the estimated swap'
    )


class SwapExactCoinOut(BaseModel):
    """
    Specification of a swap with an exact amount out
    """

    swap_amount_out: Optional[str] = Field(
        None, description='Amount to get out of the swap'
    )
    swap_operations: Optional[List[SwapOperation]] = Field(
        None, description='Operations required to execute the swap'
    )
    swap_venue: Optional[SwapVenue] = Field(
        None, description='Swap venue that this swap should execute on'
    )
    price_impact_percent: Optional[str] = Field(
        None, description='Price impact of the estimated swap'
    )


class SwapInWrapper(BaseModel):
    swap_in: Optional[SwapExactCoinIn] = None


class SwapOutWrapper(BaseModel):
    swap_out: Optional[SwapExactCoinOut] = None


class AxelarTransfer1(BaseModel):
    axelar_scan_link: Optional[str] = Field(
        None, description='Link to the transaction on the Axelar Scan explorer'
    )
    dst_chain_id: Optional[str] = Field(
        None, description='Chain ID of the destination chain'
    )
    src_chain_id: Optional[str] = Field(
        None, description='Chain ID of the source chain'
    )
    state: Optional[AxelarTransferState] = None
    txs: Optional[Union[ContractCallWithTokenTxs, SendTokenTxs]] = None
    type: Optional[AxelarTransferType] = None


class AxelarTransferInfo(BaseModel):
    axelar_transfer: Optional[AxelarTransfer1] = None


class Packet(BaseModel):
    acknowledge_tx: Optional[PacketTransaction] = None
    error: Optional[PacketError] = None
    receive_tx: Optional[PacketTransaction] = None
    send_tx: Optional[PacketTransaction] = None
    timeout_tx: Optional[PacketTransaction] = None


class Swap1(SwapInWrapper):
    estimated_affiliate_fee: Optional[str] = Field(
        None, description='Estimated total affiliate fee generated by the swap'
    )


class Swap2(SwapOutWrapper):
    estimated_affiliate_fee: Optional[str] = Field(
        None, description='Estimated total affiliate fee generated by the swap'
    )


class Swap(BaseModel):
    __root__: Union[Swap1, Swap2]


class SwapWrapper(BaseModel):
    swap: Optional[Swap] = None


class TransferInfo(BaseModel):
    dst_chain_id: Optional[str] = Field(
        None, description='Chain ID of the destination chain'
    )
    packet_txs: Optional[Packet] = None
    src_chain_id: Optional[str] = Field(
        None, description='Chain ID of the source chain'
    )
    state: Optional[TransferState] = None


class IBCTransferInfo(BaseModel):
    ibc_transfer: Optional[TransferInfo] = None


class Operation(BaseModel):
    __root__: Union[
        TransferWrapper, SwapWrapper, AxelarTransferWrapper, BankSendWrapper
    ]


class RouteResponse(BaseModel):
    amount_in: Optional[str] = Field(
        None, description='Amount of source asset to be transferred or swapped'
    )
    amount_out: Optional[str] = Field(
        None, description='Amount of destination asset out'
    )
    chain_ids: Optional[List[str]] = Field(
        None,
        description='Chain-ids of all chains of the transfer or swap, in order of usage by operations in the route',
    )
    dest_asset_chain_id: Optional[str] = Field(
        None, description='Chain-id of the destination asset'
    )
    dest_asset_denom: Optional[str] = Field(
        None, description='Denom of the destination asset'
    )
    does_swap: Optional[bool] = Field(
        None, description='Whether this route performs a swap'
    )
    estimated_amount_out: Optional[str] = Field(
        None, description='Amount of destination asset out, if a swap is performed'
    )
    operations: Optional[List[Operation]] = Field(
        None, description='Array of operations required to perform the transfer or swap'
    )
    source_asset_chain_id: Optional[str] = Field(
        None, description='Chain-id of the source asset'
    )
    source_asset_denom: Optional[str] = Field(
        None, description='Denom of the source asset'
    )
    swap_venue: Optional[SwapVenue] = Field(
        None,
        description='Swap venue on which the swap is performed, if a swap is performed',
    )
    txs_required: Optional[int] = Field(
        None,
        description='Number of transactions required to perform the transfer or swap',
    )
    usd_amount_in: Optional[str] = Field(
        None, description='Amount of the source denom, converted to USD value'
    )
    usd_amount_out: Optional[str] = Field(
        None,
        description='Amount of the destination denom expected to be received, converted to USD value',
    )
    swap_price_impact_percent: Optional[str] = Field(
        None, description='Price impact of the estimated swap, if present'
    )


class TransferEvent(BaseModel):
    __root__: Union[IBCTransferInfo, AxelarTransferInfo]


class TransferStatus(BaseModel):
    error: Optional[StatusError] = None
    next_blocking_transfer: Optional[NextBlockingTransfer] = Field(
        None,
        description='Indicates which entry in the `transfer_sequence` field that the transfer is blocked on. Will be null if there is no blocked transfer.',
    )
    state: Optional[TransactionState] = None
    transfer_asset_release: Optional[TransferAssetRelease] = Field(
        None, description='Indicates location and denom of transfer asset release.'
    )
    transfer_sequence: Optional[List[TransferEvent]] = Field(
        None, description='Lists any IBC and Axelar transfers as they are seen.'
    )
